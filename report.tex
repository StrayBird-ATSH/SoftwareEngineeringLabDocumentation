\documentclass[a4paper]{report}
\pagestyle{headings}
\usepackage{hyperref}
\usepackage{listings}
\lstset{language=bash}
\lstset{numbers=right}
\lstset{breaklines}
\title{Lab Report for Software Engineering course \newline
 Lab 1: Git \& Dev Cloud}
\author{Wang, Chen \\ 16307110064 \\ School of Software\\ Fudan University}
\date{\today}
\bibliographystyle{plain}
\begin{document}
\maketitle

\tableofcontents

\chapter{Background Knowledge of the lab}
\section{Version Control System}
\subsection{The application of VCS}
\par
A component of software configuration management, version control, also known as revision control or source control, is the management of changes to documents, computer programs, large web sites, and other collections of information. Changes are usually identified by a number or letter code, termed the "revision number", "revision level", or simply "revision". For example, an initial set of files is "revision 1". When the first change is made, the resulting set is "revision 2", and so on. Each revision is associated with a timestamp and the person making the change. Revisions can be compared, restored, and with some types of files, merged.

\par
The need for a logical way to organize and control revisions has existed for almost as long as writing has existed, but revision control became much more important, and complicated when the era of computing began. The numbering of book editions and of specification revisions are examples that date back to the print-only era. Today, the most capable (as well as complex) revision control systems are those used in software development, where a team of people may concurrently make changes to the same files.

\par
Version control systems (VCS) most commonly run as stand-alone applications, but revision control is also embedded in various types of software such as word processors and spreadsheets, collaborative web docs and in various content management systems, e.g., Wikipedia's page history. Revision control allows for the ability to revert a document to a previous revision, which is critical for allowing editors to track each other's edits, correct mistakes, and defend against vandalism and spamming in wikis.

\subsection{The general usage of VCS}
\par
In computer software engineering, revision control is any kind of practice that tracks and provides control over changes to source code. Software developers sometimes use revision control software to maintain documentation and configuration files as well as source code.
\par
As teams design, develop and deploy software, it is common for multiple versions of the same software to be deployed in different sites and for the software's developers to be working simultaneously on updates. Bugs or features of the software are often only present in certain versions (because of the fixing of some problems and the introduction of others as the program develops). Therefore, for the purposes of locating and fixing bugs, it is vitally important to be able to retrieve and run different versions of the software to determine in which version(s) the problem occurs. It may also be necessary to develop two versions of the software concurrently: for instance, where one version has bugs fixed, but no new features (branch), while the other version is where new features are worked on (trunk).
\par
At the simplest level, developers could simply retain multiple copies of the different versions of the program, and label them appropriately. This simple approach has been used in many large software projects. While this method can work, it is inefficient as many near-identical copies of the program have to be maintained. This requires a lot of self-discipline on the part of developers and often leads to mistakes. Since the code base is the same, it also requires granting read-write-execute permission to a set of developers, and this adds the pressure of someone managing permissions so that the code base is not compromised, which adds more complexity. Consequently, systems to automate some or all of the revision control process have been developed. This ensures that the majority of management of version control steps is hidden behind the scenes.
\par
Moreover, in software development, legal and business practice and other environments, it has become increasingly common for a single document or snippet of code to be edited by a team, the members of which may be geographically dispersed and may pursue different and even contrary interests. Sophisticated revision control that tracks and accounts for ownership of changes to documents and code may be extremely helpful or even indispensable in such situations.
\par
Revision control may also track changes to configuration files, such as those typically stored in /etc or /usr/local/etc on Unix systems. This gives system administrators another way to easily track changes made and a way to roll back to earlier versions should the need arise.
\subsection{Various tools for VCS}
\subsubsection{Differences between distributive and non-distributive VCS systems}
\par
Distributed version control systems (DVCS) takes a peer-to-peer approach to version control, as opposed to the clientâ€“server approach of centralized systems. Distributed revision control synchronizes repositories by exchanging patches from peer to peer. There is no single central version of the codebase; instead, each user has a working copy and the full change history.
\par
Advantages of DVCS (compared with centralized systems) include:
\begin{enumerate}
  \item Allows users to work productively when not connected to a network.
  \item Common operations (such as commits, viewing history, and reverting changes) are faster for DVCS, because there is no need to communicate with a central server. With DVCS, communication is only necessary when sharing changes among other peers.
  \item Allows private work, so users can use their changes even for early drafts they do not want to publish.
  \item Working copies effectively function as remote backups, which avoids relying on one physical machine as a single point of failure.
  \item Allows various development models to be used, such as using development branches or a Commander/Lieutenant model.
  \item Permits centralized control of the "release version" of the project
  \item On FOSS software projects it is much easier to create a project fork from a project that is stalled because of leadership conflicts or design disagreements.
\end{enumerate}
\par
Disadvantages of DVCS (compared with centralized systems) include:
\begin{enumerate}
  \item Initial checkout of a repository is slower as compared to checkout in a centralized version control system, because all branches and revision history are copied to the local machine by default.
  \item The lack of locking mechanisms that is part of most centralized VCS and still plays an important role when it comes to non-mergeable binary files such as graphic assets.
  \item Additional storage required for every user to have a complete copy of the complete codebase history.
\end{enumerate}
\par
Some originally centralized systems now offer some distributed features. For example, Subversion is able to do many operations with no network. Team Foundation Server and Visual Studio Team Services now host centralized and distributed version control repositories via hosting Git.

\section{Git}
\subsection{The feature of Git in comparison to other VCS tools}
\subsubsection{Strong support for non-linear development}
\par
Git supports rapid branching and merging, and includes specific tools for visualizing and navigating a non-linear development history. In Git, a core assumption is that a change will be merged more often than it is written, as it is passed around to various reviewers. In Git, branches are very lightweight: a branch is only a reference to one commit. With its parental commits, the full branch structure can be constructed.
\subsubsection{Distributed development}
Like Darcs, BitKeeper, Mercurial, SVK, Bazaar, and Monotone, Git gives each developer a local copy of the full development history, and changes are copied from one such repository to another. These changes are imported as added development branches and can be merged in the same way as a locally developed branch.
\subsubsection{Compatibility with existent systems and protocols}
Repositories can be published via Hypertext Transfer Protocol (HTTP), File Transfer Protocol (FTP), rsync (removed in Git 2.8.0), or a Git protocol over either a plain socket, or Secure Shell (ssh). Git also has a CVS server emulation, which enables the use of extant CVS clients and IDE plugins to access Git repositories. Subversion and svk repositories can be used directly with git-svn.
\subsubsection{Efficient handling of large projects}
Torvalds has described Git as being very fast and scalable, and performance tests done by Mozilla showed that it was an order of magnitude faster than some version-control systems; fetching version history from a locally stored repository can be one hundred times faster than fetching it from the remote server.
\subsubsection{Cryptographic authentication of history}
The Git history is stored in such a way that the ID of a particular version (a commit in Git terms) depends upon the complete development history leading up to that commit. Once it is published, it is not possible to change the old versions without it being noticed. The structure is similar to a Merkle tree, but with added data at the nodes and leaves. (Mercurial and Monotone also have this property.)
\subsubsection{Toolkit-based design}
Git was designed as a set of programs written in C and several shell scripts that provide wrappers around those programs. Although most of those scripts have since been rewritten in C for speed and portability, the design remains, and it is easy to chain the components together.
\subsubsection{Pluggable merge strategies}
As part of its toolkit design, Git has a well-defined model of an incomplete merge, and it has multiple algorithms for completing it, culminating in telling the user that it is unable to complete the merge automatically and that manual editing is needed.
\subsubsection{Garbage accumulates until collected}
Aborting operations or backing out changes will leave useless dangling objects in the database. These are generally a small fraction of the continuously growing history of wanted objects. Git will automatically perform garbage collection when enough loose objects have been created in the repository. Garbage collection can be called explicitly using \lstinline !git gc --prune! .
\subsubsection{Periodic explicit object packing}
Git stores each newly created object as a separate file. Although individually compressed, this takes a great deal of space and is inefficient. This is solved by the use of packs that store a large number of objects delta-compressed among themselves in one file (or network byte stream) called a packfile. Packs are compressed using the heuristic that files with the same name are probably similar, but do not depend on it for correctness. A corresponding index file is created for each packfile, telling the offset of each object in the packfile. Newly created objects (with newly added history) are still stored as single objects, and periodic repacking is needed to maintain space efficiency. The process of packing the repository can be very computationally costly. By allowing objects to exist in the repository in a loose but quickly generated format, Git allows the costly pack operation to be deferred until later, when time matters less, e.g., the end of a work day. Git does periodic repacking automatically, but manual repacking is also possible with the \lstinline !git gc! command. For data integrity, both the packfile and its index have an SHA-1 checksum inside, and the file name of the packfile also contains an SHA-1 checksum. To check the integrity of a repository, run the \lstinline!git fsck! command.
\subsection{The application of Git}

Git is a distributed version-control system for tracking changes in source code during software development. It is designed for coordinating work among programmers, but it can be used to track changes in any set of files. Its goals include speed, data integrity, and support for distributed, non-linear workflows.
Git was created by Linus Torvalds in 2005 for development of the Linux kernel, with other kernel developers contributing to its initial development. Its current maintainer since 2005 is Junio Hamano.
As with most other distributed version-control systems, and unlike most clientâ€“server systems, every Git directory on every computer is a full-fledged repository with complete history and full version-tracking abilities, independent of network access or a central server.
Git is free and open-source software distributed under the terms of the GNU General Public License version 2.

\subsection{The general usage of Git}
\subsubsection{Working with local repositories}
\paragraph{git init}
This command turns a directory into an empty Git repository. This is the first step in creating a repository. After running git init, adding and committing files/directories is possible.
Usage:


\begin{lstlisting}[language=bash]
# change directory to codebase
$ cd /file/path/to/code

# make directory a git repository
$ git init
\end{lstlisting}

\paragraph{git add}
Adds files in the to the staging area for Git. Before a file is available to commit to a repository, the file needs to be added to the Git index (staging area). There are a few different ways to use git add, by adding entire directories, specific files, or all unstaged files.
Usage:
\begin{lstlisting}[language=bash]
$ git add <file or directory name>
\end{lstlisting}
\paragraph{git commit}
Record the changes made to the files to a local repository. For easy reference, each commit has a unique ID.
Itâ€™s best practice to include a message with each commit explaining the changes made in a commit. Adding a commit message helps to find a particular change or understanding the changes.
Usage:
\begin{lstlisting}[language=bash]
# Adding a commit with message
$ git commit -m "Commit message in quotes"
\end{lstlisting}

\paragraph{git status}
This command returns the current state of the repository.
\emph{git status} will return the current working branch. If a file is in the staging area, but not committed, it shows with \emph{git status}. Or, if there are no changes it'll return \emph{nothing to commit, working directory clean}.
Usage:
\begin{lstlisting}[language=bash]
$ git status
\end{lstlisting}

\paragraph{git config}
With Git, there are many configurations and settings possible. \emph{git config} is how to assign these settings. Two important settings are user user.name and user.email. These values set what email address and name commits will be from on a local computer. With \emph{git config}, a \emph{--global} flag is used to write the settings to all repositories on a computer. Without a \emph{--global} flag settings will only apply to the current repository that you are currently in.
There are many other variables available to edit in \emph{git config}. From editing color outputs to changing the behavior of \emph{git status}.
Usage:
\begin{lstlisting}[language=bash]
$ git config <setting> <command>
\end{lstlisting}

\paragraph{git branch}
To determine what branch the local repository is on, add a new branch, or delete a branch.
Usage:
\begin{lstlisting}[language=bash]
# Create a new branch
$ git branch <branch_name>

# List all remote or local branches
$ git branch -a

# Delete a branch
$ git branch -d <branch_name>
\end{lstlisting}


\paragraph{git checkout}
To start working in a different branch, use \emph{git checkout} to switch branches.
Usage:
\begin{lstlisting}[language=bash]
# Checkout an existing branch
$ git checkout <branch_name>

# Checkout and create a new branch with that name
$ git checkout -b <new_branch>
\end{lstlisting}

\paragraph{git merge}
Integrate branches together. \emph{git merge} combines the changes from one branch to another branch. For example, merge the changes made in a staging branch into the stable branch.
Usage:
\begin{lstlisting}[language=bash]
# Merge changes into current branch
$ git merge <branch_name>
\end{lstlisting}
\subsubsection{Working with remote repositories}
\paragraph{git remote}
To connect a local repository with a remote repository. A remote repository can have a name set to avoid having to remember the URL of the repository.
Usage:
\begin{lstlisting}[language=bash]
# Add remote repository
$ git remote <command> <remote_name> <remote_URL>

# List named remote repositories
$ git remote -v
\end{lstlisting}

\paragraph{git clone}
To create a local working copy of an existing remote repository, use \emph{git clone} to copy and download the repository to a computer. Cloning is the equivalent of \emph{git init} when working with a remote repository. Git will create a directory locally with all files and repository history.
Usage:
\begin{lstlisting}[language=bash]
$ git clone <remote_URL>
\end{lstlisting}

\paragraph{git pull}
To get the latest version of a repository run \emph{git pull}. This pulls the changes from the remote repository to the local computer.
Usage:
\begin{lstlisting}[language=bash]
$ git pull <branch_name> <remote_URL/remote_name>
\end{lstlisting}


\paragraph{git push}
Sends local commits to the remote repository. \emph{git push} requires two parameters: the remote repository and the branch that the push is for.
Usage:
\begin{lstlisting}[language=bash]
$ git push <remote_URL/remote_name> <branch>

# Push all local branches to remote repository
$ git push -all
\end{lstlisting}

\subsection{The usage of Git in this lab}
In this lab, we are going to utilize Git to get and modify the code created by the teaching assistant, upload them to the server and then finish other consequent operations. Therefore, the critical steps in our lab include
\begin{enumerate}
  \item Clone the code from the Huawei cloud repository;
  \item Commit our changes to the Git system;
  \item Push our commit onto the Huawei cloud repository.
\end{enumerate}
\subsubsection{Clone}
To check out the code from the repository on the Huawei Cloud platform, we ought to navigate to \url{classroom.devcloud.huaweicloud.com}, login via IAM method, enter the project and navigate to the code management section. The Lab1 section is shown in the list allowing us to clone/download the repository from the cloud. As we select the "via HTTPS" method, we get a link enabling us to clone the code from the Git console. 
After getting the link, we can clone the code by entering the following the command below: 
\begin{lstlisting}[language=bash]
git clone https://codehub.devcloud.huaweicloud.com/2019rjgc_Lab1_xzstudent00300001/Lab1.git
\end{lstlisting}
\par
After cloning the repository without specifying the path to save the contents, we will get the downloaded files in the user folder by default.
\subsubsection{Commit}
After changing the source code, we can view the changes we have made by using the \textbf{git status} command in the git root folder. The changes will be displayed in the command line window. As we confirm the changes we have made, we can commit the changes by input the \textbf{git commit} command to commit the changes. It should be noted that the commit message is required for each commit we have made. A commit successful message will be shown after a successful commit.
\subsubsection{Push}
After committing the specified codes into the local repository, we can push the commits into the cloud repository. If we have made multiple commits, they will be pushed to the cloud in the single push command.
\par
Since we have specified the remote repositories where we pulled the codes from, we will be free from entering the remote address of the repository again. A single \textbf{git push} command will be able to instruct the git system to push all the commits to the remote repository at the Huawei Cloud.
\section{Java EE}
\subsection{The needs and application of Java EE}
Java Platform, Enterprise Edition (Java EE) is the standard in community-driven enterprise software. Java EE is developed using the Java Community Process, with contributions from industry experts, commercial and open source organizations, Java User Groups, and countless individuals. Each release integrates new features that align with industry needs, improves application portability, and increases developer productivity.
\par
Today, Java EE offers a rich enterprise software platform and with over 20 compliant Java EE implementations to choose from.
\par
As stated above, the Java EE platform is designed to help developers create large-scale, multitiered, scalable, reliable, and secure network applications. A shorthand name for such applications is enterprise applications, so called because these applications are designed to solve the problems encountered by large enterprises. Enterprise applications are not only useful for large corporations, agencies, and governments, however. The benefits of an enterprise application are helpful, even essential, for individual developers and small organizations in an increasingly networked world.
\par
The features that make enterprise applications powerful, like security and reliability, often make these applications complex. The Java EE platform reduces the complexity of enterprise application development by providing a development model, API, and runtime environment that allow developers to concentrate on functionality.
\subsection{Common frameworks of Java EE}
According to some online materials, I have discovered that there are a list of Spring framework that are most commonly used by enterprises across the world. Ordered by popularity, these frameworks are:
\begin{enumerate}
  \item \textbf{Spring MVC.} Old but gold, Spring MVC is still ahead of the curve after more than a decade since its first release. After its expansion to embrace complete MVC framework, Spring kept on evolving adopting changes and turned into a full-scale Java framework for Internet-facing applications, offering software engineers a powerful toolkit for web application development and application configuration as well as for security projects.
  \item \textbf{Struts 2.} To elaborate even more on existing Java frameworks that are widely used by modern software engineers, we decided to refer to the successor of Apacheâ€™s Struts 1, Struts 2. This Java framework is quite a find for engineers who work with building contemporary Java EE web apps.
  \item \textbf{Hibernate.} Although not on RebelLabsâ€™ list either, it is worth mentioning Hibernate when debating the best Java framework. This mapping Java framework cracks object-relational impedance mismatch issues by substituting persisting DB accesses high-level object handling functions.
  \item \textbf{JSF.} Being a part of Java EE, JavaServer Faces is supported by Oracle. Although this one is not the best frameworks for speedy Java development, it is easy to utilize because of great documentation provided by Oracle.
  \item \textbf{Vaadin.} Using GWT for rendering the end web page, Vaadin became one of the uber popular frameworks modern developers choose when creating applications for business. Utilizing a well-known component-based approach, Vaadin takes the burden off developerâ€™s shoulder by communicating the changes made to the browser.
  \item \textbf{Google Web Toolkit.} GWT is an another free Java framework allowing coders to create and optimize sophisticated web-based apps.
  \item \textbf{Grails.} This particular web framework is regarded as a dynamic tool enhancing engineersâ€™ productivity due to its opinionated APIs, sensible defaults, as well as its convention-over-configuration paradigm. Seamless Java integration makes this particular framework one of the top choices for plenty of programmers worldwide.
\end{enumerate}
\section{Spring Boot}
\subsection{The feature of Spring Boot in comparison to other Java EE frameworks}
\subsection{The usage of Spring Boot in this lab}
\section{Classroom platform of Huawei Cloud}
\subsection{The functionalities of Huawei Cloud}
\subsection{The functions of Huawei Cloud used in this lab}
\section{Life cycle in software engineering}
\subsection{The meaning of life cycle in software engineering}
\subsection{The life cycle displayed in this lab}
AAAW
\chapter{Specification of the Lab}
\section{Platform of the operation}
\section{Guideline of the operation steps}
\section{Hand in method and materials}
\chapter{Steps of accomplishing this Lab}
\section{Git operations}
\section{SpringBoot framework construction}
\section{Executions on the SpringBoot framework}
\chapter{Significance of different parts of the lab}
\chapter{Conclusion}
\end{document} 